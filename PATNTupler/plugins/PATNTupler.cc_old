// -*- C++ -*-
//
// Package:    PATNTupler
// Class:      PATNTupler
// 
/**\class PATNTupler PATNTupler.cc NTupler/PATNTupler/src/PATNTupler.cc

 Description: [one line class summary]


 Implementation:
     [Notes on implementation]
*/
//
// Original Author:  Emmanuel Olaiya
//         Created:  Tue Dec 21 11:15:57 BST 2011
// $Id: PATNTupler.cc,v 1.9 2011/12/21 11:15:57 olaiya Exp $
//
//


// system include files
#include <memory>

// user include files
#include "FWCore/Framework/interface/Frameworkfwd.h"
#include "FWCore/Framework/interface/EDAnalyzer.h"

#include "DataFormats/VertexReco/interface/Vertex.h"
#include "DataFormats/VertexReco/interface/VertexFwd.h"

#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/MakerMacros.h"

#include "FWCore/ParameterSet/interface/ParameterSet.h"

#include "FWCore/Framework/interface/ESHandle.h"

#include "FWCore/Utilities/interface/Exception.h"

//Add headers for PAT objects
#include "DataFormats/PatCandidates/interface/PATObject.h"
#include "DataFormats/PatCandidates/interface/Muon.h"
#include "DataFormats/PatCandidates/interface/Electron.h"
#include "DataFormats/PatCandidates/interface/Jet.h"

//To use the GenParticle MC-truth collection...
#include "DataFormats/HepMCCandidate/interface/GenParticle.h"

//...for the GSF electron collection...
#include "DataFormats/EgammaCandidates/interface/GsfElectron.h"

//...for the calo geometry classes ...
#include "Geometry/CaloGeometry/interface/CaloGeometry.h"
#include "Geometry/Records/interface/CaloGeometryRecord.h"

// ... for using the recHits collections and information ...
#include "RecoCaloTools/MetaCollections/interface/CaloRecHitMetaCollections.h"
#include "DataFormats/Common/interface/SortedCollection.h"

// ... for the general tracks collection
#include "DataFormats/TrackReco/interface/Track.h"

//...in order to use the heep::Ele class ...
#include "SHarper/HEEPAnalyzer/interface/HEEPEle.h"
#include "SHarper/HEEPAnalyzer/interface/HEEPEleSelector.h"

//...for accessing the tevMuons and their cocktail tracks ...
#include <DataFormats/MuonReco/interface/Muon.h>
#include "DataFormats/MuonReco/interface/MuonCocktails.h"

//...for accessing the HLT configuration & trigger decisions
#include <HLTrigger/HLTcore/interface/HLTConfigProvider.h>
#include <DataFormats/Common/interface/TriggerResults.h>

//...for accessing trigger objects
#include "DataFormats/HLTReco/interface/TriggerObject.h"
#include "DataFormats/HLTReco/interface/TriggerEvent.h"

//Muon tuning
#include "DataFormats/MuonReco/interface/MuonCocktails.h" 

//...for histograms creation
#include "FWCore/ServiceRegistry/interface/Service.h"
#include "CommonTools/UtilAlgos/interface/TFileService.h"
#include "TH1.h"
#include "TGraphAsymmErrors.h"

//...for NTuple generation
#include "TTree.h"
#include "TLorentzVector.h"
#include "Math/Vector3D.h"
#include "Math/Vector4D.h"

//Must include TROOT.h in order for the gROOT->ProcessLine(...) lines to work.
#include "TROOT.h"
#include "TSystem.h"
#include "TClassTable.h"

//BOOST LIBRARIES
#include <boost/shared_ptr.hpp>

#include "NTupler/PATNTupler/interface/EventInfo.hh"
#include "NTupler/PATNTupler/interface/Particles.hh"


//
// class declaration
//

class PATNTupler : public edm::EDAnalyzer {
   public:
      explicit PATNTupler(const edm::ParameterSet&);
      ~PATNTupler();

      static void fillDescriptions(edm::ConfigurationDescriptions& descriptions);


   private:
      virtual void beginJob() ;
      virtual void analyze(const edm::Event&, const edm::EventSetup&);
      virtual void endJob() ;

      virtual void beginRun(const edm::Run&, const edm::EventSetup&);

		///For clearing contents/setting default values of variables that should get new values in each event...
		void ResetEventByEventVariables();

		///For reading the event information into the member variables...
		void ReadInEvtInfo(bool, const edm::Event&);

                ///For reading in the electron information, and dumping it into ran::Event class ...
		void ReadInElectrons(const edm::Event&);

		///For reading in the muon information, and dumping it into ran::Event class ...
		void ReadInMuons(const edm::Event&);

                ///For reading in the Jet information, and dumping it into ran::Event class ...
		void ReadInJets(const edm::Event&);

      // ----------member data ---------------------------
  /*TH1D *eleHighestEt_EtHist;
		TH1D *ele2ndHighestEt_EtHist;
		TH1D *fracAboveSingleEleEtThreshold_Hist; */
		edm::Service<TFileService> fHistos;
		TTree* EventDataTree;

		int numEvts;
		unsigned int numEvtsStored_;
		int dyJetsToLL_EventType_;
                bool mcFlag_;
		bool vBool_;

		//Variables whose values will be stored as branches...
		//ran::Event* event_;
                ran::EventInfo evtInfo;
                std::vector<ran::ElectronStruct>* electronCollection;
                std::vector<ran::MuonStruct>* muonCollection;
                std::vector<ran::JetStruct>* jetCollection;

		unsigned int numFinalStateEles;		
		
		// Trigger member variables
		Bool_t      trg_PathA_decision_;
		std::string trg_PathA_name_;
		
  /*		edm::InputTag hltResultsTag_;
		edm::InputTag hltEventTag_;
		std::string hltPathA_;
		const std::vector<std::string> hltPathA_possNames_;
		bool hltPathADecision_;
		std::string hltPathA_nameOfLastFilter_;
		float hltPathA_highestTrigObjEt_;*/
 
  //TGraphAsymmErrors* highestEtTrigObjPathA_EtThrAsymmEffi_;
		//Trigger member variables - HLT config helper
		HLTConfigProvider hltConfig_;
  		unsigned hltPathIndex_;
		 // Trigger member variables - emu cross trigger
		const std::vector<std::string> trg_emuPath_possNames_;
		std::string trg_emuPath_name_;
		unsigned int trg_emuPath_idx_;

		//Event information variables...
		unsigned int evt_runNum_;
		unsigned int evt_lumiSec_;
		unsigned int evt_evtNum_;

  heep::EleSelector cuts_;
  edm::InputTag eleRhoCorrLabel_; 
  edm::InputTag verticesLabel_;
  bool applyRhoCorrToEleIsol_;
	


};

//
// constants, enums and typedefs

//
// static data member definitions
//

//
// constructors and destructor
//
PATNTupler::PATNTupler(const edm::ParameterSet& iConfig):
	numEvts(0),
	numEvtsStored_(0),
	dyJetsToLL_EventType_(iConfig.getUntrackedParameter<int>("dyJetsToLL_EventType",0)), //==0=>Don't select events, ==11=>ele, ==13=>muon, ==15=>tau
	mcFlag_(iConfig.getUntrackedParameter<bool>("isMC",0)),
	vBool_(iConfig.getUntrackedParameter<bool>("printOutInfo",0)),
	trg_emuPath_idx_(999999), cuts_(iConfig)

{
   //now do what ever initialization is needed
        eleRhoCorrLabel_=iConfig.getParameter<edm::InputTag>("eleRhoCorrLabel");
        applyRhoCorrToEleIsol_=iConfig.getParameter<bool>("applyRhoCorrToEleIsol");
	verticesLabel_ = iConfig.getParameter<edm::InputTag>("verticesLabel");
	//For TTree and TBranch creation...
	EventDataTree = fHistos->make<TTree>("EventDataTree", "Electron event data");

	//Setting up the links between variables and branches...
	//event_ = 0;	
	//EventDataTree->Branch("event","ran::Event", &event_, 64000, 1); // This line was taken from Jim's tupiliser
        EventDataTree->Branch("evtInfo","ran::EventInfo",&evtInfo);
        EventDataTree->Branch("electronCollection","std::vector<ran::ElectronStruct>", &electronCollection, 64000, 1); 
        EventDataTree->Branch("muonCollection","std::vector<ran::MuonStruct>", &muonCollection, 64000, 1); 
        EventDataTree->Branch("jetCollection","std::vector<ran::JetStruct>", &jetCollection, 64000, 1);
}


PATNTupler::~PATNTupler()
{
 
   // do anything here that needs to be done at desctruction time
   // (e.g. close files, deallocate resources etc.)

}


//
// member functions
//

// ------------ method called for each event  ------------
void
PATNTupler::analyze(const edm::Event& iEvent, const edm::EventSetup& iSetup)
{
	//Variable declarations...
	numFinalStateEles = 0;
	reco::Candidate::LorentzVector particle4mom(0.0, 0.0, 0.0, 0.0);
	//event_ = new ran::Event();
	//electronCollection = boost::shared_ptr<std::vector<ran::ElectronStruct> > (new std::vector<ran::ElectronStruct>());
	electronCollection = new std::vector<ran::ElectronStruct>();
	muonCollection = new std::vector<ran::MuonStruct>();
	jetCollection = new std::vector<ran::JetStruct>();

   using namespace edm;
	
	//Clearing contents/setting default values of variables that should get new values in each event...
	ResetEventByEventVariables();

	//Reading in the event information...
	ReadInEvtInfo(vBool_, iEvent);
	
	numEvts++;

	//Reading in the kin variables for the standard and special reco'n GSF electrons... 

	ReadInMuons(iEvent);
      
        //Read in Electrons
        ReadInElectrons(iEvent);

	//Read in Jets
	ReadInJets(iEvent);

	Int_t zBosonDaughter_PDGid = 0;	
	
	//Reset branch addresses here each time...
	if(dyJetsToLL_EventType_==0){
		numEvtsStored_++;
		EventDataTree->Fill();
	}
	else if( (dyJetsToLL_EventType_!=0) && (abs(zBosonDaughter_PDGid)==dyJetsToLL_EventType_) ){
		numEvtsStored_++;
		EventDataTree->Fill();
	}

	//delete event_;
	delete electronCollection;
	delete muonCollection;
	delete jetCollection;

#ifdef THIS_IS_AN_EVENT_EXAMPLE
   Handle<ExampleData> pIn;
   iEvent.getByLabel("example",pIn);
#endif
   
#ifdef THIS_IS_AN_EVENTSETUP_EXAMPLE
   ESHandle<SetupData> pSetup;
   iSetup.get<SetupRecord>().get(pSetup);
#endif
}


// ------------ method called once each job just before starting event loop  ------------
void 
PATNTupler::beginJob()
{
}

// ------------ method called when starting to processes a run  ------------
void 
PATNTupler::beginRun(const edm::Run& run, const edm::EventSetup& iSetup){
	
}

// ------------ method called once each job just after ending the event loop  ------------
void PATNTupler::endJob()
{

	
	std::cout << "   done." << std::endl;
	
	
	fHistos->cd();
	EventDataTree->Write();

	std::cout << std::endl;
	std::cout << " ***************************************" << std::endl;
	std::cout << " * " << numEvtsStored_ << " events have been stored in the NTuple";
	std::cout << std::endl;
}

/*// ------------ method called when ending the processing of a run  ------------
void 
PATNTupler::endRun(edm::Run const&, edm::EventSetup const&)
{
}*/

/*// ------------ method called when starting to processes a luminosity block  ------------
void 
PATNTupler::beginLuminosityBlock(edm::LuminosityBlock const&, edm::EventSetup const&)
{
}

// ------------ method called when ending the processing of a luminosity block  ------------
void 
PATNTupler::endLuminosityBlock(edm::LuminosityBlock const&, edm::EventSetup const&)
{
}*/

// ------------ methods for setting up the pointer links between the branches and the variables...

// ------------ method fills 'descriptions' with the allowed parameters for the module  ------------
void
PATNTupler::fillDescriptions(edm::ConfigurationDescriptions& descriptions) {
  //The following says we do not know what parameters are allowed so do no validation
  // Please change this to state exactly what you do use, even if it is no parameters
  edm::ParameterSetDescription desc;
  desc.setUnknown();
  descriptions.addDefault(desc);
}

//define this as a plug-in
DEFINE_FWK_MODULE(PATNTupler);


//------------ method for clearing contents/setting default values of variables that should get new values in each event -------------
void
PATNTupler::ResetEventByEventVariables(){
	
	//Resetting the values of the event information variables...
	evtInfo.runNum = 0;
	evtInfo.evtNum = 0;
	evtInfo.lumiSec = 0;
	
	
	
}



//----------------------------------------------------------------------------------------------------
//------------ method for reading in the event information (run no., lumi sec etc...)  ---------------
void PATNTupler::ReadInEvtInfo(bool beVerbose, const edm::Event& edmEventObject){

        evtInfo.runNum = edmEventObject.id().run();
	evtInfo.lumiSec = edmEventObject.id().luminosityBlock();
	evtInfo.evtNum = edmEventObject.id().event();
}

//Read in electron vars
void PATNTupler::ReadInElectrons(const edm::Event& edmEvent)
{
  edm::Handle<edm::View<pat::Electron> > electronHandle;
  edmEvent.getByLabel("cleanPatElectrons",electronHandle);
  
  //find the start and end of container
  //edm::View<pat::Electron>::const_iterator startOfEleHandle = electronHandle->begin();
  //edm::View<pat::Electron>::const_iterator endOfEleHandle = electronHandle->end();

  edm::Handle<double> rhoHandle;
  edmEvent.getByLabel(eleRhoCorrLabel_,rhoHandle);
  double rho = applyRhoCorrToEleIsol_ ? *rhoHandle : 0;
 
  //double rho = 0;

  edm::Handle<reco::VertexCollection> verticesHandle;
  edmEvent.getByLabel(verticesLabel_,verticesHandle);
  math::XYZPoint pvPos(0,0,0);
  if(!verticesHandle->empty()) pvPos = verticesHandle->front().position();
  

  // get electron collection
  edm::Handle<std::vector<pat::Electron> > electrons;
  edmEvent.getByLabel("cleanPatElectrons", electrons); 

  std::vector<pat::Electron>::const_iterator startOfEleHandle = electrons->begin();
  std::vector<pat::Electron>::const_iterator endOfEleHandle = electrons->end();

  //should push back directly into the Event here
  //for(edm::View<pat::Electron>::const_iterator iEle = startOfEleHandle; iEle !=endOfEleHandle ; ++iEle){
for(std::vector<pat::Electron>::const_iterator iEle = startOfEleHandle; iEle !=endOfEleHandle ; ++iEle){
    ran::ElectronStruct ithElec;

    ithElec.pt = iEle->pt();
    ithElec.eta = iEle->eta();

    ithElec.gsfTrack_available = iEle->gsfTrack().isAvailable();
    ithElec.scEta = iEle->superCluster()->eta();
    ithElec.scEnergy = iEle->superCluster()->energy();
    ithElec.ecalDrivenSeed = iEle->ecalDrivenSeed();
    ithElec.e2x5Max = iEle->e2x5Max();
    ithElec.e5x5 = iEle->e5x5();
    ithElec.e1x5 = iEle->e1x5();
    ithElec.deltaPhiSuperClusterTrackAtVtx = iEle->deltaPhiSuperClusterTrackAtVtx();
    ithElec.hadronicOverEm = iEle->hadronicOverEm();
    ithElec.nrMissHits = iEle->gsfTrack()->trackerExpectedHitsInner().numberOfHits();
    ithElec.scSigmaIEtaIEta = iEle->scSigmaIEtaIEta();
    ithElec.dr03EcalRecHitSumEt = iEle->dr03EcalRecHitSumEt();
    ithElec.dr03HcalDepth1TowerSumEt = iEle->dr03HcalDepth1TowerSumEt();
    ithElec.dr03TkSumPt = iEle->dr03TkSumPt();
    ithElec.pfIso_chgHad = iEle->pfIsolationVariables().chargedHadronIso;
    ithElec.pfIso_neutHad = iEle->pfIsolationVariables().neutralHadronIso;
    ithElec.pfIso_pht = iEle->pfIsolationVariables().photonIso;

    heep::Ele heepEle(*iEle);//instantiate HEEP variable
    //HEEP variables
   
    //Variables storing the heep::Ele method values ...
    ithElec.heep_et = heepEle.et();
    ithElec.heep_gsfEt =    heepEle.gsfEt();
    ithElec.heep_scEt   =   heepEle.scEt();
    ithElec.heep_energy  =  heepEle.energy();
    ithElec.heep_gsfEnergy = heepEle.gsfEnergy();
    ithElec.heep_caloEnergy= heepEle.caloEnergy();
    ithElec.heep_ecalEnergyError = heepEle.gsfEle().ecalEnergyError();
    ithElec.heep_eta     =  heepEle.eta();
    ithElec.heep_scEta =      heepEle.scEta();
    ithElec.heep_detEta =     heepEle.detEta();
    ithElec.heep_detEtaAbs =  heepEle.detEtaAbs();
    ithElec.heep_phi =        heepEle.phi();
    ithElec.heep_scPhi =      heepEle.scPhi();
    ithElec.heep_detPhi =     heepEle.detPhi();
    ithElec.heep_zVtx =       heepEle.zVtx();
    ithElec.heep_p4 =         heepEle.p4();
    ithElec.heep_gsfP4 =      heepEle.gsfP4();

    //Variables storing the heep::Ele method values - Classification...
    ithElec.heep_classification =  heepEle.classification();
    ithElec.heep_isEcalDriven =    heepEle.isEcalDriven();
    ithElec.heep_isTrackerDriven = heepEle.isTrackerDriven();
    ithElec.heep_isEB =            heepEle.isEB();
    ithElec.heep_isEE =            heepEle.isEE();

    //Variables storing the heep::Ele method values - track methods ...
    ithElec.heep_charge =    heepEle.charge();
    ithElec.heep_trkCharge = heepEle.trkCharge();
    ithElec.heep_pVtx =      heepEle.pVtx();
    ithElec.heep_pCalo =     heepEle.pCalo();
    ithElec.heep_ptVtx =     heepEle.ptVtx();
    ithElec.heep_ptCalo =    heepEle.ptCalo();

    if(heepEle.gsfEle().closestCtfTrackRef().get()==0){
      ithElec.heep_closestCtfTrk_pt = -999.9;
      ithElec.heep_closestCtfTrk_eta = -999.9;
      ithElec.heep_closestCtfTrk_phi = -999.9;
      /*
	ithElec.heep_closestCtfTrk_innerPt = -999.9;
	ithElec.heep_closestCtfTrk_innerEta = -999.9;
	ithElec.heep_closestCtfTrk_innerPhi = -999.9;
	ithElec.heep_closestCtfTrk_outerPt = -999.9;
	ithElec.heep_closestCtfTrk_outerEta = -999.9;
	ithElec.heep_closestCtfTrk_outerPhi = -999.9; */
    }
    else{
      ithElec.heep_closestCtfTrk_pt = heepEle.gsfEle().closestCtfTrackRef().get()->pt();
      ithElec.heep_closestCtfTrk_eta = heepEle.gsfEle().closestCtfTrackRef().get()->eta();
      ithElec.heep_closestCtfTrk_phi = heepEle.gsfEle().closestCtfTrackRef().get()->phi();
    }

    //Variables storing the heep::Ele method values ...
    ithElec.heep_hOverE =      heepEle.hOverE();
    ithElec.heep_dEtaIn =      heepEle.dEtaIn();
    ithElec.heep_dPhiIn =      heepEle.dPhiIn();
    ithElec.heep_dPhiOut =     heepEle.dPhiOut();
    ithElec.heep_epIn =        heepEle.epIn();
    ithElec.heep_epOut =       heepEle.epOut();
    ithElec.heep_fbrem =       heepEle.fbrem();
    ithElec.heep_bremFrac =    heepEle.bremFrac();
    ithElec.heep_invEOverInvP = heepEle.invEOverInvP();

    //Variables storing the heep::Ele method values - shower shape variables ...
    //ithElec.heep_sigmaEtaEta =      heepEle.sigmaEtaEta();
    ithElec.heep_sigmaEtaEtaUnCorr = heepEle.sigmaEtaEtaUnCorr();
    ithElec.heep_sigmaIEtaIEta =    heepEle.sigmaIEtaIEta();
    ithElec.heep_e1x5 =             heepEle.e1x5();
    ithElec.heep_e2x5Max =          heepEle.e2x5Max();
    ithElec.heep_e5x5 =             heepEle.e5x5();
    ithElec.heep_e1x5Over5x5 =      heepEle.e1x5Over5x5();
    ithElec.heep_e2x5MaxOver5x5 =   heepEle.e2x5MaxOver5x5();

    //ithElec.heep_scSigmaEtaEta = heepEle.scSigmaEtaEta();
    ithElec.heep_scSigmaEtaEtaUnCorr = heepEle.scSigmaEtaEtaUnCorr();
    ithElec.heep_scSigmaIEtaIEta = heepEle.scSigmaIEtaIEta();
    ithElec.heep_scE1x5 = heepEle.scE1x5();
    ithElec.heep_scE2x5Max = heepEle.scE2x5Max();
    ithElec.heep_scE5x5 = heepEle.scE5x5();
    ithElec.heep_scE1x5Over5x5 = heepEle.scE1x5Over5x5();
    ithElec.heep_scE2x5MaxOver5x5 = heepEle.scE2x5MaxOver5x5();

    //isolation, we use cone of 0.3
    //first our rho correction funcs
    ithElec.heep_rhoForIsolCorr = heepEle.rhoForIsolCorr();
    ithElec.heep_applyRhoIsolCorr = heepEle.applyRhoIsolCorr();

    //Variables storing the heep::Ele method values - isolation variables ...
    ithElec.heep_isolEm =         heepEle.isolEm();
    ithElec.heep_isolHad =        heepEle.isolHad();
    ithElec.heep_isolHadDepth1 =  heepEle.isolHadDepth1();
    ithElec.heep_isolHadDepth2 =  heepEle.isolHadDepth2();
    ithElec.heep_isolPtTrks =     heepEle.isolPtTrks();
    ithElec.heep_isolEmHadDepth1 = heepEle.isolEmHadDepth1();

    ithElec.heep_isolPtTrksRel03 = heepEle.isolPtTrksRel03();
    ithElec.heep_isolEmRel03 = heepEle.isolEmRel03();
    ithElec.heep_isolHadRel03 = heepEle.isolHadRel03();

    ithElec.heep_numMissInnerHits = heepEle.nrMissHits();

    ithElec.heep_cutCode = cuts_.getCutCode(rho,pvPos,*iEle);

    //std::cout << std::hex <<  ithElec.heep_cutCode << ": hex value\n";
    //Fill electron collection
    electronCollection->push_back(ithElec); //copying to vector. Rather than instantiating an object, filling it
    //and then copying it to vector, instaniate in a vector and fill in the vector. At least look into using rvalues
    //.ie moves if you can use C++11
    
  }

}

//Read in jet vars
void PATNTupler::ReadInJets(const edm::Event& edmEvent)
{
  edm::Handle<edm::View<pat::Jet> > jetHandle;
  edmEvent.getByLabel("selectedPatJetsPFlow",jetHandle);
  
  //find the start and end of container
  edm::View<pat::Jet>::const_iterator startOfJetHandle = jetHandle->begin();
  edm::View<pat::Jet>::const_iterator endOfJetHandle = jetHandle->end();

  //should push back directly into the Event here
  for(edm::View<pat::Jet>::const_iterator iJet = startOfJetHandle; iJet !=endOfJetHandle ; ++iJet){
    ran::JetStruct ithJet;
    ithJet.et = iJet->et();
    ithJet.eta = iJet->eta();

     //Assign the btag discriminators
    ithJet.jetProbabilityBJetTags =  iJet->bDiscriminator("jetProbabilityBJetTags");
    ithJet.jetBProbabilityBJetTags =  iJet->bDiscriminator("jetBProbabilityBJetTags");
    ithJet.trackCountingHighEffBJetTags =  iJet->bDiscriminator("trackCountingHighEffBJetTags");   
    ithJet.trackCountingHighPurBJetTags =  iJet->bDiscriminator("trackCountingHighPurBJetTags");
    ithJet.simpleSecondaryVertexBJetTags =  iJet->bDiscriminator("simpleSecondaryVertexBJetTags");
    ithJet.combinedSecondaryVertexBJetTags =  iJet->bDiscriminator("combinedSecondaryVertexBJetTags");
    ithJet.combinedSecondaryVertexMVABJetTags =  iJet->bDiscriminator("combinedSecondaryVertexMVABJetTags");
    ithJet.impactParameterMVABJetTags =  iJet->bDiscriminator("impactParameterMVABJetTags");
    ithJet.softElectronBJetTags =  iJet->bDiscriminator("softElectronBJetTags");
    ithJet.softMuonBJetTags =  iJet->bDiscriminator("softMuonBJetTags");
    ithJet.softMuonNoIPBJetTags =  iJet->bDiscriminator("softMuonNoIPBJetTags");

    ithJet.partonFlavour = iJet->partonFlavour();
    jetCollection->push_back(ithJet);
    //event_->AddJet(ithJet);
  }

}


//------------ method for reading in the values of the standard GSF electron variables ---------------
//----------------------------------------------------------------------------------------------------
//-------- Method for reading in the muon information, and dumping it into tsw::Event class ----------
void PATNTupler::ReadInMuons(const edm::Event& edmEvent){

  // Grab beamspot and highest pt-sum vertex
  edm::Handle<reco::BeamSpot> h_beamSpot;
  edmEvent.getByLabel("offlineBeamSpot", h_beamSpot);
  if( ! h_beamSpot.isValid() )
    std::cout << "WARNING!! Error will occur soon since handle to beam spot is not valid!\n";

  edm::Handle<reco::VertexCollection> h_vertices;
  edmEvent.getByLabel("offlinePrimaryVertices", h_vertices);
  if( ! h_vertices.isValid() )
    std::cout << "WARNING!! Error will occur soon since hande to primary vertices is not valid!\n";

  std::vector<reco::Vertex>::const_iterator mainPrimaryVertexIt(h_vertices->begin());
  double mainPrimaryVtx_sumTrackPts = 0.0;

  for(std::vector<reco::Vertex>::const_iterator vertexIt = h_vertices->begin();
      vertexIt != h_vertices->end(); vertexIt++ )
    {
      // Apply basic quality cuts to vertex ...
      bool goodQualityVtx = (vertexIt->tracksSize()>=4) && ( vertexIt->z()<24. && sqrt( pow(vertexIt->x(),2.0)+pow(vertexIt->y(),2.0) )<2.0 );
      if( goodQualityVtx )
	{
	  double ithVtx_sumTrackPts = 0.0;
	  for(std::vector<reco::Track>::const_iterator trkIt=vertexIt->refittedTracks().begin(); trkIt!=vertexIt->refittedTracks().end(); trkIt++)
	    ithVtx_sumTrackPts += sqrt(trkIt->innerMomentum().perp2());

	  if(ithVtx_sumTrackPts > mainPrimaryVtx_sumTrackPts)
	    mainPrimaryVertexIt = vertexIt;
	}
    }

  //i am duplicating above loop. Only need one
  const reco::VertexCollection vC = *(h_vertices.product());
  reco::VertexCollection::const_iterator pVtx;
  bool pVertexFound(false);
  if (!h_vertices->empty()){
    for(reco::VertexCollection::const_iterator vtx=vC.begin() ; vtx!=vC.end() ; ++vtx){
      if (vtx->isValid()){
	pVtx = vtx;
	pVertexFound = true;
	break;//jump out of loop
      }
    }
  }

  edm::View<pat::Muon>::const_iterator imuon;

  edm::Handle<edm::View<pat::Muon> > muonC;
  edmEvent.getByLabel("cleanPatMuons",muonC); 

  // Running over the muons in the collection ...
  for(imuon = muonC->begin(); imuon != muonC->end(); ++imuon){
    //OK fill my muons
    ran::MuonStruct aMuon;
    aMuon.pt = imuon->pt();
    aMuon.eta = imuon->eta();
    aMuon.p4                 = imuon->p4();
    aMuon.charge             = imuon->charge();
    aMuon.isGlobalMuon       = imuon->isGlobalMuon();
    aMuon.isTrackerMuon      = imuon->isTrackerMuon();
    aMuon.isStandAloneMuon   = imuon->isStandAloneMuon();
    aMuon.numMatchedMuonStns = imuon->numberOfMatchedStations();
   
    aMuon.dB                 = imuon->dB();

    aMuon.isPFIsolationValid = imuon->isPFIsolationValid();
    aMuon.pfIsoR03_sumChgHadPt  = imuon->pfIsolationR03().sumChargedHadronPt;
    aMuon.pfIsoR03_chgPartPt = imuon->pfIsolationR03().sumChargedParticlePt;
    aMuon.pfIsoR03_sumNeutHadPt =  imuon->pfIsolationR03().sumNeutralHadronEt;
    aMuon.pfIsoR03_sumPhtEt =  imuon->pfIsolationR03().sumPhotonEt;
    aMuon.isIsolationValid   = imuon->isIsolationValid();
    aMuon.isolR03_sumPt      = imuon->isolationR03().sumPt;
    aMuon.isolR03_emEt       = imuon->isolationR03().emEt;
    aMuon.isolR03_hadEt      = imuon->isolationR03().hadEt;

    
    // Global track information ...
    if(imuon->globalTrack().get()!=0){
      aMuon.globTrk_exists = true;
      aMuon.globTrk_pT            = imuon->globalTrack()->pt();
      aMuon.globTrk_eta           = imuon->globalTrack()->eta();
      aMuon.globTrk_phi           = imuon->globalTrack()->phi();
      aMuon.globTrk_charge        = imuon->globalTrack()->charge();
      aMuon.globTrk_numberOfValidMuonHits = imuon->globalTrack()->hitPattern().numberOfValidMuonHits();
      aMuon.globTrk_normalisedChi2 = imuon->globalTrack()->normalizedChi2();
    } else {
      aMuon.globTrk_exists = false;
    }

    // Inner track information ...
    if(imuon->innerTrack().get()!=0){
      aMuon.inTrk_exists = true;
      aMuon.inTrk_pT               = imuon->innerTrack()->pt();
      aMuon.inTrk_eta              = imuon->innerTrack()->eta();
      aMuon.inTrk_phi              = imuon->innerTrack()->phi();
      aMuon.inTrk_charge           = imuon->innerTrack()->charge();
      aMuon.inTrk_numValidPixHits  = imuon->innerTrack()->hitPattern().numberOfValidPixelHits();
      aMuon.inTrk_numValidTrkrHits = imuon->innerTrack()->hitPattern().numberOfValidTrackerHits();
      aMuon.inTrk_trackerLayersWithMeasurement =  imuon->innerTrack()->hitPattern().trackerLayersWithMeasurement();
      aMuon.inTrk_dxyVsOrigin      = imuon->innerTrack()->dxy(); // Really, this should be calculated as innerTrack()->dxy(vertex->position()), but no vertex information is read in at the moment, and MuonRecoPerformance2010 TWiki page => Can calculate this approximately just relative to (0,0,0)
      aMuon.trk_trkrLayersWHits    = imuon->track()->hitPattern().trackerLayersWithMeasurement();
    } else {
      aMuon.inTrk_exists = false;
    }

    // Outer track information ...
    if(imuon->outerTrack().get()!=0){
      aMuon.outTrk_exists = true;
      aMuon.outTrk_pT     = imuon->outerTrack()->pt();
      aMuon.outTrk_eta    = imuon->outerTrack()->eta();
      aMuon.outTrk_phi    = imuon->outerTrack()->phi();
      aMuon.outTrk_charge = imuon->outerTrack()->charge();
    } else {
      aMuon.outTrk_exists = false;
    }

          
    if( imuon->muonBestTrack().get()!=0 ){
      aMuon.bestTrk_exists = true;
      aMuon.bestTrk_dxy_bspot   = imuon->muonBestTrack()->dxy( h_beamSpot->position() );
      aMuon.bestTrk_dxy_vtx     = imuon->muonBestTrack()->dxy( mainPrimaryVertexIt->position() );
      aMuon.bestTrk_dz_vtx      = imuon->muonBestTrack()->dz( mainPrimaryVertexIt->position() );
      aMuon.dxy                = imuon->muonBestTrack()->dxy(pVtx->position());
      aMuon.dz                 = imuon->muonBestTrack()->dz(pVtx->position());

      reco::TrackRef cktTrack = (muon::tevOptimized(*imuon, 200, 40., 17., 0.25)).first; //not needed for CMSSW_5_3_6_patch1  and higher

      aMuon.pTune_pt          = cktTrack->pt();
      aMuon.pTune_ptError     = cktTrack->ptError();
      aMuon.pTune_dxy         = cktTrack->dxy(pVtx->position());
      aMuon.pTune_dz          = cktTrack->dz(pVtx->position());
    } else {
      aMuon.bestTrk_exists = false;
    }

    

    //add muon to Muon collection
    muonCollection->push_back(aMuon);
    //event_->AddMuon(aMuon);
  }
}

//----------------------------------------------------------------------------------------------------
